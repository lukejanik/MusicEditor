package cs3500.music.model;

import java.util.ArrayList;

/**
 * This is the class for MusicEditorModel.
 */
public final class MusicEditorModel implements IMusicEditorModel {

  MusicEditorModel() {
    // No parameters.
  }

  /**
   * Adds the note at its beat number to the given piece.
   * If the beat number does not exist in the piece, the note is still added to the piece.
   * If the beat number does exist in the piece, the note is added to that beat and all beats
   * within the duration of the note.
   *
   * @param note  The note to add to the piece
   * @param piece The piece to add the note to
   */
  @Override
  public void write(Playable note, Piece piece) {
    piece.addNote(note);
  }
  
   /**
   * To replace an old note with a new note.
   *
   * @param oldSym the note that is to be replaced.
   * @param newSym the note that the oldNote will be replaced with.
   * @param piece  the piece that is to be edited. -- pass a list<Pieces> </Pieces>
   */
  @Override
  public void edit(AMusicSymbol oldSym, AMusicSymbol newSym, Piece piece) {
    piece.editSym(oldSym, newSym);
  }
  
  /**
   * To remove a given note from the given piece.
   *
   * @param sym   note to be removed.
   * @param piece piece that the note will be removed from.
   */
  @Override
  public void remove(Playable note, Piece piece) {
    piece.removeNote(note);
  }
  
  /**
   * To combine a list of pieces either simultaneously or consecutively.
   *
   * @param type   The type of combination you want to make (simultaneous or consecutive).
   * @param pieces The list of pieces that are to be combined.
   */
  @Override
  public Piece combine(CombineType type, List<Piece> pieces) {
    switch (type) {
      case CONSECUTIVE:
        Piece combo = new Piece();

         // Add the first
    for (Beat beat : piecesToCombine.get(0).beats) {
      for (Playable p : beat.notes) {
        combo.addNote(p);
      }
    }
    int size = piecesToCombine.get(0).beats.size();
    for (int i = 1; i < piecesToCombine.size(); i++) {
      for (Beat beat : piecesToCombine.get(i).beats) {
        for (Playable p : beat.notes) {
          Playable n = new Note(p.getPitch(), p.getOctave(), p.getDuration(), p.getBeatNumber() +
                  size);
          combo.addNote(n);
        }
      }
      size += piecesToCombine.get(i).beats.size();
    }

    return combo;

      case SIMULTANEOUS:
        int maxLength = 0;
        for (Piece p : pieces) {
          if (p.size() > maxLength) {
            maxLength = p.size();
          }
        }
        Piece simulPiece = new Piece();
        simulPiece.addBeats(maxLength);
        for (Piece p : pieces) {
          simulPiece.addMusicSymbols(p);
        }
        return simulPiece;
      default:
        throw new IllegalArgumentException("Invalid combination type");
    }
  }
  
   /**
   * To return a string of the editorState of the given piece.
   *
   * @param piece The piece that is part of the music editor.
   * @return String of the editorState of the given piece.
   */
  @Override
  public String getEditorState(Piece piece) {
    return piece.setUpState();
  }
}
  
